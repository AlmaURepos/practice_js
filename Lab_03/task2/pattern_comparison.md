# Pattern Comparison and Evolution

## Сравнение паттернов

### Module Pattern vs Revealing Module Pattern
- **Module Pattern**: возвращает объект с публичными методами, приватные члены скрыты внутри IIFE.
- **Revealing Module Pattern**: публичные методы и свойства явно перечисляются в возвращаемом объекте, что делает API более прозрачным и поддерживаемым.

### Module Pattern vs ES6 Modules
- **Module Pattern**: основан на функциях и замыканиях, работает во всех версиях JS.
- **ES6 Modules**: стандарт языка, поддерживает `import`/`export`, статический анализ, tree-shaking, изоляцию на уровне файлов.

### Module Pattern vs Namespace Pattern
- **Module Pattern**: обеспечивает инкапсуляцию и приватность.
- **Namespace Pattern**: только группирует функции/переменные, не скрывает приватные данные.

## Когда использовать
- **Module Pattern**: для совместимости со старыми проектами, когда нет поддержки ES6.
- **Revealing Module Pattern**: когда нужен явный и поддерживаемый публичный API.
- **ES6 Modules**: для современных приложений, модульной структуры, поддержки инструментов сборки.
- **Namespace Pattern**: для простого логического объединения кода без инкапсуляции.

## Эволюция
Модульный паттерн был необходимостью до появления стандартных модулей. С ES6 предпочтение отдаётся нативным модулям, но паттерн важен для понимания принципов инкапсуляции и поддержки старого кода.

## Ссылки
- Ch. 3, “Writing a Pattern”
- Ch. 7, “JavaScript Design Patterns”
- Ch. 5, “ES6 Modules”
- Ch. 11, “Namespace Pattern”
